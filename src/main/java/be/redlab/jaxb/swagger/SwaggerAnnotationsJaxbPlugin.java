/*
 *  Copyright 2017 Balder Van Camp
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package be.redlab.jaxb.swagger;

import be.redlab.jaxb.swagger.constants.ApiModelPropertyFields;
import be.redlab.jaxb.swagger.process.AbstractProcessStrategy;
import be.redlab.jaxb.swagger.process.FieldProcessStrategy;
import be.redlab.jaxb.swagger.process.NoProcessStrategy;
import be.redlab.jaxb.swagger.process.PropertyProcessStrategy;
import be.redlab.jaxb.swagger.process.PublicMemberProcessStrategy;
import com.sun.codemodel.JAnnotationUse;
import com.sun.codemodel.JDefinedClass;
import com.sun.tools.xjc.Options;
import com.sun.tools.xjc.Plugin;
import com.sun.tools.xjc.outline.ClassOutline;
import com.sun.tools.xjc.outline.EnumOutline;
import com.sun.tools.xjc.outline.Outline;
import com.sun.tools.xjc.reader.xmlschema.bindinfo.BindInfo;
import com.sun.xml.xsom.XSAnnotation;
import io.swagger.annotations.ApiModel;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import javax.xml.bind.annotation.XmlAccessType;
import java.text.MessageFormat;
import java.util.Collection;
import java.util.EnumMap;
import java.util.Map;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * The SwaggerAnnotationsJaxbPlugin adds Swaggers {@link io.swagger.annotations.ApiModel} and {@link io.swagger.annotations.ApiModelProperty} to JAXB Generated classes.
 * Currently only working with Field Accessor annotations.
 *
 * @author redlab
 */
public class SwaggerAnnotationsJaxbPlugin extends Plugin {

    private static final Logger log = Logger.getLogger(SwaggerAnnotationsJaxbPlugin.class.getName());

    private static final String DESCRIPTION_CLASS = " description generated by jaxb-swagger, hence no class description yet.";

    private static final String WARNING_SKIPPING = "Skipping %s as it is not an implementation or class";

    private static final String SWAGGERIFY = "swaggerify";

    private static final String USAGE = "Add this plugin to the JAXB classes generator classpath and provide the argument '-swaggerify'.";

    private static final Map<XmlAccessType, AbstractProcessStrategy> processStrategyMap = new EnumMap<>(XmlAccessType.class);

    static {
        processStrategyMap.put(XmlAccessType.NONE, new NoProcessStrategy());
        processStrategyMap.put(XmlAccessType.FIELD, new FieldProcessStrategy());
        processStrategyMap.put(XmlAccessType.PROPERTY, new PropertyProcessStrategy());
        processStrategyMap.put(XmlAccessType.PUBLIC_MEMBER, new PublicMemberProcessStrategy());
    }

    /**
     * The optio name to activate swagger annotations.
     *
     * @return swaggerify
     */
    @Override
    public String getOptionName() {
        return SWAGGERIFY;

    }

    /**
     * A usage description
     */
    @Override
    public String getUsage() {
        return USAGE;
    }

    /**
     * The run method called by XJC.
     */
    @Override
    public boolean run(final Outline outline, final Options opt, final ErrorHandler errorHandler) throws SAXException {
        Collection<? extends ClassOutline> classes = outline.getClasses();
        Collection<EnumOutline> enums = outline.getEnums();
        for (ClassOutline o : classes) {
            annotateClass(errorHandler, enums, o);
        }
        return true;
    }

    private void annotateClass(ErrorHandler errorHandler, Collection<EnumOutline> enums, ClassOutline classOutline) throws SAXException {
        JDefinedClass implClass = classOutline.implClass;
        if (isProperClass(implClass)) {
            Collection<JAnnotationUse> annotations = implClass.annotations();
            if (!annotations.isEmpty()) {
                XmlAccessType access = XJCHelper.getAccessType(annotations);
                if (Objects.nonNull(access)) {
                    addClassAnnotation(classOutline);
                    ProcessStrategy processStrategy = getProcessStrategy(access);
                    logStrategyAndClass(classOutline, processStrategy);
                    processStrategy.process(implClass, classOutline.target, enums);
                }
            }
        } else {
            errorHandler.warning(new SAXParseException(String.format(WARNING_SKIPPING, classOutline), null));
        }
    }

    private void logStrategyAndClass(ClassOutline classOutline, ProcessStrategy processStrategy) {
        if (log.isLoggable(Level.FINE)) {
            String message = MessageFormat.format("[{0}] using [{1}] strategy to process class and its fields", classOutline.implClass, processStrategy.getClass());
            log.log(Level.FINE, message);
        }
    }

    /**
     * Add the class level annotation, {@link io.swagger.annotations.ApiModel}
     *
     * @param classOutline the ClassOutline
     */
    private void addClassAnnotation(final ClassOutline classOutline) {
        JAnnotationUse apiClass = classOutline.implClass.annotate(ApiModel.class);
        String value = classOutline.target.isElement() ? classOutline.target.getElementName().getLocalPart() : classOutline.ref.name();
        String documentation = getDocumentation(classOutline);
        apiClass.param(ApiModelPropertyFields.VALUE, value);
        apiClass.param(ApiModelPropertyFields.DESCRIPTION, (documentation != null) ? documentation : classOutline.ref.fullName() + DESCRIPTION_CLASS);
    }

    /**
     * Extract value from {@code <xs:annotation><xs:documentation>} if exists.
     *
     * @param o the ClassOutline
     * @return value from {@code <xs:annotation><xs:documentation>} or <code>null</code> if
     * {@code <xs:annotation><xs:documentation>} does not exists.
     */
    private String getDocumentation(final ClassOutline o) {
        XSAnnotation annotation = o.target.getSchemaComponent().getAnnotation();
        return (annotation != null && annotation.getAnnotation() instanceof BindInfo)
            ? ((BindInfo) annotation.getAnnotation()).getDocumentation()
            : null;
    }

    private ProcessStrategy getProcessStrategy(final XmlAccessType access) {
        return processStrategyMap.get(access);
    }

    private boolean isProperClass(JDefinedClass implClass) {
        return null != implClass && implClass.isClass() && !implClass.isAbstract() && !implClass.isInterface()
            && !implClass.isAnnotationTypeDeclaration();
    }


}
